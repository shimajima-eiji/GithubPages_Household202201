<h1>
<span id="公式リファレンス" class="fragment"></span><a href="#%E5%85%AC%E5%BC%8F%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9"><i class="fa fa-link"></i></a>公式リファレンス</h1>
<h2>
<span id="github-docs" class="fragment"></span><a href="#github-docs"><i class="fa fa-link"></i></a>Github Docs</h2>
<p><qiita-embed-ogp src="https://docs.github.com/ja/actions/learn-github-actions/contexts"></qiita-embed-ogp></p>
<p>本稿ではstepsコンテキストを使っています</p>
<h2>
<span id="実行結果によって処理をするしないを分岐する" class="fragment"></span><a href="#%E5%AE%9F%E8%A1%8C%E7%B5%90%E6%9E%9C%E3%81%AB%E3%82%88%E3%81%A3%E3%81%A6%E5%87%A6%E7%90%86%E3%82%92%E3%81%99%E3%82%8B%E3%81%97%E3%81%AA%E3%81%84%E3%82%92%E5%88%86%E5%B2%90%E3%81%99%E3%82%8B"><i class="fa fa-link"></i></a>実行結果によって処理をする・しないを分岐する</h2>
<p>先に結論を言うと、runでif文を書けるので、shellを書くのと同じ感覚で書けばやりたい事は実現できます。<br>
ロギングがしたいならechoでログを出すか、ログファイルも更新してpushすればGithubActionsを探しに行かなくてよくなります。</p>
<p>が、ここではGithubActionsの流儀に則って制御を考えます。<br>
また、runで実行すると、途中でエラーになった時にどこで失敗したのか特定するのが難しくなるので、運用を考えるならなるべく切り分けたいからです。</p>
<p>やり方は、<code>if: 条件</code>をいれるだけです。<br>
問題は、条件に何を書くかです。</p>
<h3>
<span id="条件分岐で使えるもの" class="fragment"></span><a href="#%E6%9D%A1%E4%BB%B6%E5%88%86%E5%B2%90%E3%81%A7%E4%BD%BF%E3%81%88%E3%82%8B%E3%82%82%E3%81%AE"><i class="fa fa-link"></i></a>条件分岐で使えるもの</h3>
<p>色々なものが使えますが、ここでやりたいのは「前回実行したステップの結果を受け取りたい」というものです。<br>
たとえば、前回実行した結果が全て完了したとか、特定の処理をしたかどうか。<br>
解決アプローチとして、３つのパターンがあります。</p>
<ol>
<li>そもそもstepをまとめてしまう</li>
<li>前stepの結果を判定するロジックをrunで書く</li>
<li>【今回採用】stepを実行する前にif条件を入れる</li>
</ol>
<p>大事な事なのでもう一度繰り返します。<br>
うまく行かない場合は、今回採用する方法にこだわる必要はありません。<br>
実務で採用する場合にまで、後でできる事を今こだわるとハマって進捗率を下げてしまう、なんて事も考えられます。<br>
状況に合わせて活用してください。</p>
<h4>
<span id="ソース例と解説" class="fragment"></span><a href="#%E3%82%BD%E3%83%BC%E3%82%B9%E4%BE%8B%E3%81%A8%E8%A7%A3%E8%AA%AC"><i class="fa fa-link"></i></a>ソース例と解説</h4>
<p>今回の制御で見る公式ドキュメントの位置</p>
<p><qiita-embed-ogp src="https://docs.github.com/ja/actions/learn-github-actions/contexts#steps-context"></qiita-embed-ogp></p>
<p>Thanks:</p>
<p><qiita-embed-ogp src="https://qiita.com/ljourm/items/556f5ccc8425891865de"></qiita-embed-ogp></p>
<p><code>if: steps.(ステップのid).outcome == "success"</code>が最もわかりやすいです。<br>
以下のような使い方ができます。</p>
<div class="code-frame" data-lang="yaml">
<div class="code-lang"><span class="bold">成功.yml</span></div>
<div class="highlight"><pre><code><span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">確実に成功する処理</span>
  <span class="na">id</span><span class="pi">:</span> <span class="s">test1</span>
  <span class="na">continue-on-error</span><span class="pi">:</span> <span class="no">true</span>  <span class="c1"># 処理が失敗しても継続させる</span>
  <span class="na">run</span><span class="pi">:</span> <span class="s">echo "成功"</span>

<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">実行される事を確認</span>
  <span class="na">if</span><span class="pi">:</span> <span class="s">steps.test1.outcome == "success"</span>
  <span class="na">run</span><span class="pi">:</span> <span class="s">echo "処理される"</span>
</code></pre></div>
</div>
<div class="code-frame" data-lang="yaml">
<div class="code-lang"><span class="bold">失敗.yml</span></div>
<div class="highlight"><pre><code><span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">確実に失敗する処理</span>
  <span class="na">id</span><span class="pi">:</span> <span class="s">test2</span>
  <span class="na">continue-on-error</span><span class="pi">:</span> <span class="no">true</span>  <span class="c1"># 処理が失敗しても継続させる</span>
  <span class="na">run</span><span class="pi">:</span> <span class="s">exit </span><span class="m">1</span>

<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">実行される事を確認</span>
  <span class="na">if</span><span class="pi">:</span> <span class="s">steps.test2.outcome == "success"</span>
  <span class="na">run</span><span class="pi">:</span> <span class="s">echo "スキップ"</span>
</code></pre></div>
</div>
<div class="code-frame" data-lang="yaml">
<div class="code-lang"><span class="bold">失敗した時でも処理したい.yml</span></div>
<div class="highlight"><pre><code><span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">確実に失敗する処理</span>
  <span class="na">id</span><span class="pi">:</span> <span class="s">test2</span>
  <span class="na">continue-on-error</span><span class="pi">:</span> <span class="no">true</span>  <span class="c1"># 処理が失敗しても継続させる</span>
  <span class="na">run</span><span class="pi">:</span> <span class="s">exit </span><span class="m">1</span>

<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">実行される事を確認</span>
  <span class="na">if</span><span class="pi">:</span> <span class="s">steps.test2.outcome == "success"</span>
  <span class="na">run</span><span class="pi">:</span> <span class="s">echo "スキップ"</span>
</code></pre></div>
</div>
<p>適当なリポジトリを作って、<code>.github/workflows</code>以下に置いて検証してみてください。</p>
<h4>
<span id="実践例" class="fragment"></span><a href="#%E5%AE%9F%E8%B7%B5%E4%BE%8B"><i class="fa fa-link"></i></a>実践例</h4>
<p>この方法は、Ubuntu20.04にデフォルトで入っているpythonのバージョンが古くて動かないスクリプトがある場合、処理をしないための例です。</p>
<p>参考</p>
<p><qiita-embed-ogp src="https://docs.python.org/ja/3/library/pathlib.html#pathlib.PurePath.with_stem"></qiita-embed-ogp></p>
<p>Ubuntu22.04 LTSではどうなるか気になるところです。</p>
<p><qiita-embed-ogp src="https://www.youtube.com/watch?v=iL-ZvDEQH0M"></qiita-embed-ogp></p>
<p><qiita-embed-ogp src="https://wiki.ubuntu.com/MitsuyaShibata/Slides"></qiita-embed-ogp></p>
<h4>
<span id="ソースコード" class="fragment"></span><a href="#%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89"><i class="fa fa-link"></i></a>ソースコード</h4>
<div class="code-frame" data-lang="yaml">
<div class="code-lang"><span class="bold">実践例.yml</span></div>
<div class="highlight"><pre><code><span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
<span class="na">steps</span><span class="pi">:</span>
  <span class="c1"># 以下、ステップ</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">PosixPath.with_stemが使えないので、スクリプトを実行できるか判断する</span>
    <span class="na">id</span><span class="pi">:</span> <span class="s">check_python</span>
    <span class="na">continue-on-error</span><span class="pi">:</span> <span class="no">true</span>
    <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
      <span class="s"># python3のマイナーバージョンが9未満か判定</span>
      <span class="s">if [ "$(python3 --version | cut -d"." -f2)" -lt "${minor}" ]</span>
      <span class="s">then</span>
        <span class="s">exit 1</span>
      <span class="s">fi</span>

  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">スクリプトを実行</span>
    <span class="na">if</span><span class="pi">:</span> <span class="s">steps.check_python.outcome == 'success'</span>
    <span class="na">run</span><span class="pi">:</span> <span class="s">python3 (実行スクリプト)</span>
</code></pre></div>
</div>
<p>check_pythonで<code>exit 1</code>を実行しなければスクリプトを実行します。</p>
<h4>
<span id="応用例" class="fragment"></span><a href="#%E5%BF%9C%E7%94%A8%E4%BE%8B"><i class="fa fa-link"></i></a>応用例</h4>
<p>この方法は、Ubuntu20.04にデフォルトで入っているpythonのバージョンが古くて動かないスクリプトを動かすための例です。<br>
<strong>もっといい方法がある</strong>ので、以下はあくまで実践例です。</p>
<p>今回のGAとは関係ないですが、WSLに入れる時に参考になりました。</p>
<p><qiita-embed-ogp src="https://codechacha.com/ja/ubuntu-install-python39/"></qiita-embed-ogp></p>
<p><qiita-embed-ogp src="https://stackoverflow.com/questions/65644782/how-to-install-pip-for-python-"></qiita-embed-ogp></p>
<h4>
<span id="ソースコード-1" class="fragment"></span><a href="#%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89-1"><i class="fa fa-link"></i></a>ソースコード</h4>
<div class="code-frame" data-lang="yaml">
<div class="code-lang"><span class="bold">応用例.yml</span></div>
<div class="highlight"><pre><code><span class="c1"># 実行環境</span>
<span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
<span class="na">steps</span><span class="pi">:</span>
  <span class="c1"># 以下、ステップ</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">判定ロジックは同じ。上記では`exit 1`で終わらせたが、こちらはインストールする</span>
    <span class="na">id</span><span class="pi">:</span> <span class="s">check_python</span>
    <span class="na">env</span><span class="pi">:</span>
      <span class="na">minor</span><span class="pi">:</span> <span class="m">9</span>
    <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
      <span class="s">pyc=$(python3)</span>

      <span class="s"># python3のマイナーバージョンが9未満の時だけ実施する</span>
      <span class="s">if [ "$(python3 --version | cut -d"." -f2)" -lt "${minor}" ]</span>
      <span class="s">then</span>
        <span class="s">sudo apt update &amp;&amp; sudo apt install software-properties-common</span>
        <span class="s">sudo add-apt-repository ppa:deadsnakes/ppa</span>
        <span class="s">sudo apt install python3.${minor}</span>
        <span class="s">pyc=python3.${minor}</span>
        <span class="s">sudo apt update &amp;&amp; sudo apt install python3.${minor}-distutils</span>
      <span class="s">fi</span>
      
      <span class="s">echo "::set-output name=pyc::${pyc}"</span>

  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">pythonスクリプト実行</span>
    <span class="na">env</span><span class="pi">:</span>
      <span class="c1"># id: check_pythonの出力からpycを取得してenvに入れる</span>
      <span class="na">pyc</span><span class="pi">:</span> <span class="s">${{ steps.check_python.outputs.pyc }}</span>
    <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
      <span class="s">${pyc} -m pip install --upgrade pip</span>
      <span class="s">${pyc} -m pip install pathlib</span>
      <span class="s">${pyc} (実行スクリプト)</span>
</code></pre></div>
</div>
<p><code>pyc</code>には<code>python3</code>か<code>python3.9</code>か、どちらかが入っています。<br>
重要なのは、実行するステップでは<code>pyc</code>に何が入っているか気にしなくても良い事です。<br>
より厳密なチェックをするなら、<code>which "${pyc}"</code>のパスが有効である事を検証するのも良いかもしれません。</p>
<h4>
<span id="良い方法" class="fragment"></span><a href="#%E8%89%AF%E3%81%84%E6%96%B9%E6%B3%95"><i class="fa fa-link"></i></a>良い方法</h4>
<p>環境構築系は自分で頑張るより、<code>uses</code>を探した方が楽です。<br>
pythonのバージョンを指定する方法はあります。</p>
<div class="code-frame" data-lang="yaml">
<div class="code-lang"><span class="bold">良い方法.yml</span></div>
<div class="highlight"><pre><code><span class="na">steps</span><span class="pi">:</span>
 <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/setup-python@v3</span>
   <span class="na">with</span><span class="pi">:</span>
     <span class="na">python-version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.9'</span>

 <span class="err"> </span><span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">pythonスクリプト実行</span>
    <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
      <span class="s">python -m pip install --upgrade pip</span>
      <span class="s">python -m pip install pathlib</span>
      <span class="s">python (実行スクリプト)</span>
</code></pre></div>
</div>
<p>あれだけ長いコードが、こんなに圧縮できるので<code>uses</code>は非常に優秀です。<br>
<code>uses</code>で使えるものは以下の通り</p>
<h5>
<span id="今回使ったもの" class="fragment"></span><a href="#%E4%BB%8A%E5%9B%9E%E4%BD%BF%E3%81%A3%E3%81%9F%E3%82%82%E3%81%AE"><i class="fa fa-link"></i></a>今回使ったもの</h5>
<p><qiita-embed-ogp src="https://github.com/actions/setup-python"></qiita-embed-ogp></p>
<h5>
<span id="使えるもの" class="fragment"></span><a href="#%E4%BD%BF%E3%81%88%E3%82%8B%E3%82%82%E3%81%AE"><i class="fa fa-link"></i></a>使えるもの</h5>
<p><qiita-embed-ogp src="https://github.com/orgs/actions/repositories"></qiita-embed-ogp></p>
<h5>
<span id="自分でusesを作れます" class="fragment"></span><a href="#%E8%87%AA%E5%88%86%E3%81%A7uses%E3%82%92%E4%BD%9C%E3%82%8C%E3%81%BE%E3%81%99"><i class="fa fa-link"></i></a>自分で<code>uses</code>を作れます</h5>
<p><code>uses</code>を見ると、<code>Githubユーザー/リポジトリ</code>の関係であることに気付きます。<br>
これは具体例を挙げるのが難しい（私が具体例を知らないため）ですが、オリジナルの環境構築ができるのは便利です。<br>
メンテナンスを考えると決して楽な選択ではありませんが、どうしてもという場合には使えそうです。</p>
<p><qiita-embed-ogp src="https://qiita.com/HeRo/items/e2d5e3bc3dbe810f0482"></qiita-embed-ogp></p>
<h2>
<span id="使用例" class="fragment"></span><a href="#%E4%BD%BF%E7%94%A8%E4%BE%8B"><i class="fa fa-link"></i></a>使用例</h2>
<p><qiita-embed-ogp src="https://nomuraya.tk/2022/03/githubactions.html"></qiita-embed-ogp></p>
<h2>
<span id="私がやりたかったこと" class="fragment"></span><a href="#%E7%A7%81%E3%81%8C%E3%82%84%E3%82%8A%E3%81%9F%E3%81%8B%E3%81%A3%E3%81%9F%E3%81%93%E3%81%A8"><i class="fa fa-link"></i></a>私がやりたかったこと</h2>
<p>pushされるたびにCHANGELOG.mdを自動で生成してPRを出すスクリプトを書きたかったんですが、</p>
<ul>
<li>github-changelogs(node)</li>
<li>github-changelog-generator(ruby)</li>
</ul>
<p>を使って自動生成する仕組みを作ろうとしていました。<br>
わざわざ自前で環境構築をやってコマンド打ち込んで…とやると大変なので、CIでなんとかならないかと思っていたところでした。<br>
いきなり難しい事をやると手がつかないので、手始めに上記のように簡単なCIを色々作ってみてGithubActionsのナレッジも蓄積してきたので、そろそろ挑戦しようと思っていました。<br>
実務ではなく趣味でやっているCIだと、CIの勉強だけだと運用経験が積めず、なかなか学びが進まないので非常に時間がかかりましたが、ようやくここまで来れました。</p>
<h2>
<span id="本稿の内容を踏まえてプログラマーを目指す方へ" class="fragment"></span><a href="#%E6%9C%AC%E7%A8%BF%E3%81%AE%E5%86%85%E5%AE%B9%E3%82%92%E8%B8%8F%E3%81%BE%E3%81%88%E3%81%A6%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9E%E3%83%BC%E3%82%92%E7%9B%AE%E6%8C%87%E3%81%99%E6%96%B9%E3%81%B8"><i class="fa fa-link"></i></a>本稿の内容を踏まえて、プログラマーを目指す方へ</h2>
<p>ぶっちゃけ本題です。<br>
冗長になりすぎたので、別記事にします。</p>
<p><qiita-embed-ogp src="https://nomuraya.tk/2022/03/consultant_learn.html"></qiita-embed-ogp></p>
